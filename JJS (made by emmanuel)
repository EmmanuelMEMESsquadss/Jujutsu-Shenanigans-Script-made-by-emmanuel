--[[
    Project: JJS Auto-Defense Core (v4.0 - VFX Hitbox Detection)
    Purpose: Stealth-oriented, hitbox-based auto-defense for JJS.
    Method: Detects the "Name" of attack VFX parts added to workspace.
    Note: All Animation and Sound logic has been removed.
--]]

-- ===================================================================
-- ===== 1. SERVICES & CORE REFERENCES
-- ===================================================================
local Services = {
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    RunService = game:GetService("RunService"),
    Players = game:GetService("Players"),
    StarterGui = game:GetService("StarterGui"),
    Stats = game:GetService("Stats"),
    Workspace = game:GetService("Workspace")
}

local LocalPlayer = Services.Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- ===================================================================
-- ===== 2. CORE MODULE INITIALIZATION
-- ===================================================================

local JJS_Core = {}
JJS_Core.__index = JJS_Core

-- ===================================================================
-- ===== 3. [CONFIGURATION] GAME-SPECIFIC DATA
-- ===================================================================
JJS_Core.GameData = {
    -- [RECON] Find the correct RemoteEvent paths in ReplicatedStorage
    Remotes = {
        Block = "Remotes:WaitForChild('Combat'):WaitForChild('Parry')", 
        Ability = "Remotes:WaitForChild('Combat'):WaitForChild('Ability')"
    },
    
    -- [RECON] These are the VFX part names from the script you found.
    -- You can add or remove part names here.
    VFX_Triggers = {
        ["CombatTrail"] = true, ["LapseBlue"] = true, ["HandTrail"] = true,
        ["Shock"] = true, ["BallFire"] = true, ["Reserve"] = true, ["Doors"] = true,
        ["TwoFold"] = true, ["Rabbit"] = true, ["Spawn"] = true, ["DivineAttack"] = true,
        ["Throw"] = true, ["FocusStrike"] = true, ["DrillImpact"] = true,
        ["Barrage"] = true, ["Mucus"] = true, ["MucusFire"] = true, ["DismantleFly"] = true,
        ["HitGlow"] = true
    },
    
    -- [RECON] These are the "Danger" VFX names for the Auto-Dodge feature.
    Dodge_Triggers = {
        ["DomainBurst"] = true, ["Domain"] = true, ["RushWind"] = true,
        ["HotHands"] = true, ["WorldSlash"] = true, ["RitualStart"] = true,
        ["EyeTrails"] = true, ["DivergentFist"] = true, ["LapseBlueMax"] = true,
        ["Purple"] = true, ["ReversalRedMax"] = true
    }
}

-- ===================================================================
-- ===== 4. SCRIPT CONFIGURATION (Live State)
-- ===================================================================
JJS_Core.Config = {
    -- Auto Block
    AutoBlock = false,
    Block_MinRange = 2.5,  -- Min distance to trigger block
    Block_MaxRange = 14.5, -- Max distance to trigger block
    
    -- Auto Dodge
    AutoDodge = false,
    Dodge_Range = 75,   -- Distance to trigger dodge
    Dodge_Distance = 45,  -- How far to teleport away
    Dodge_Cooldown = 2,
    
    -- Auto Counter
    AutoCounter = false,
    CounterAbilitySlot = 4,
    CounterAbilityCooldown = 5,
    
    -- Shared
    LocalBlockCooldown = 0.35, -- Cooldown for Block/Counter
    FacingCheck = true,
    FacingDot = -0.3,
    
    -- Combat
    Aimbot = false,
    Aimbot_Range = 20,
    
    -- Visuals
    PlayerESP = false,
    RangeVisual = false,
    
    -- Stealth
    MinReactionMS = 80,
    MaxReactionMS = 150
}

-- ===================================================================
-- ===== 5. INTERNAL STATE & CACHE
-- ===================================================================
JJS_Core.Cache = {
    Humanoid = nil,
    Animator = nil,
    RootPart = nil,
    BlockRemote = nil,
    AbilityRemote = nil,
    LastLocalBlockTime = 0,
    LastAbilityTime = 0,
    LastDodgeTime = 0,
    
    -- These tables store the *live* VFX parts
    Active_Triggers = {}, -- {BasePart}
    Active_Dangers = {}   -- {BasePart}
}

-- ===================================================================
-- ===== 6. STEALTH MODULE (Anti-Detection)
-- ===================================================================
JJS_Core.Stealth = {}

function JJS_Core.Stealth:GetRandomName(len)
    len = len or math.random(12, 24)
    local str = ""
    for i = 1, len do
        str = str .. string.char(math.random(97, 122))
    end
    return str
end

function JJS_Core.Stealth:Humanize()
    local C = JJS_Core.Config
    local minReact = math.min(C.MinReactionMS, C.MaxReactionMS)
    local maxReact = math.max(C.MinReactionMS, C.MaxReactionMS)
    local reactionTime = math.random(minReact, maxReact) / 1000
    task.wait(reactionTime)
end

-- ===================================================================
-- ===== 7. VISUALS MODULE (ESP, Trackers)
-- ===================================================================
JJS_Core.Visuals = {
    detectionCircles = {}
}

function JJS_Core.Visuals:AddESP(obj)
    if not obj:IsA("Model") then return end
    local hrp = obj:FindFirstChild("HumanoidRootPart")
    if not hrp or obj:FindFirstChild("ESP_Highlight") then return end
    local highlight = Instance.new("Highlight"); highlight.Name = "ESP_Highlight"
    highlight.FillColor = Color3.fromRGB(255, 0, 0); highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Adornee = obj; highlight.Parent = obj
    local billboard = Instance.new("BillboardGui"); billboard.Name = "ESP_Billboard"
    billboard.Size = UDim2.new(0, 100, 0, 50); billboard.AlwaysOnTop = true
    billboard.Adornee = hrp; billboard.Parent = obj
    local textLabel = Instance.new("TextLabel"); textLabel.Name = "ESP_Text"
    textLabel.Size = UDim2.new(1, 0, 1, 0); textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.fromRGB(255, 0, 0); textLabel.TextScaled = true
    textLabel.Font = Enum.Font.SourceSansBold; textLabel.Text = obj.Name
    textLabel.Parent = billboard
end

function JJS_Core.Visuals:ClearESP(obj)
    if obj:FindFirstChild("ESP_Highlight") then obj.ESP_Highlight:Destroy() end
    if obj:FindFirstChild("ESP_Billboard") then obj.ESP_Billboard:Destroy() end
end

function JJS_Core.Visuals:RefreshESP()
    for _, player in pairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if JJS_Core.Config.PlayerESP and player.Character then
                self:AddESP(player.Character)
            elseif player.Character then
                self:ClearESP(player.Character)
            end
        end
    end
end

function JJS_Core.Visuals:AddPlayerCircle(player)
    local char = player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp or self.detectionCircles[player] then return end
    local circle = Instance.new("CylinderHandleAdornment"); circle.Name = "PlayerDetectionCircle"
    circle.Adornee = hrp; circle.Color3 = Color3.fromRGB(255, 0, 0)
    circle.AlwaysOnTop = true; circle.ZIndex = 1; circle.Transparency = 0.6
    circle.Radius = JJS_Core.Config.Block_MaxRange -- Set to max block range
    circle.Height = 0.12
    local yOffset = -(hrp.Size.Y / 2 + 0.05)
    circle.CFrame = CFrame.new(0, yOffset, 0) * CFrame.Angles(math.rad(90), 0, 0)
    circle.Parent = hrp; self.detectionCircles[player] = circle
end

function JJS_Core.Visuals:RemovePlayerCircle(player)
    if self.detectionCircles[player] then
        self.detectionCircles[player]:Destroy()
        self.detectionCircles[player] = nil
    end
end

function JJS_Core.Visuals:RefreshPlayerCircles()
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if JJS_Core.Config.RangeVisual and player.Character then
                self:AddPlayerCircle(player)
            else
                self:RemovePlayerCircle(player)
            end
        end
    end
end

function JJS_Core.Visuals:Update()
    local myRoot = JJS_Core.Cache.RootPart
    if not myRoot then return end
    local C = JJS_Core.Config
    for player, visual in pairs(self.detectionCircles) do
        if C.RangeVisual and player.Character then
            visual.Radius = C.Block_MaxRange
        else
            self:RemovePlayerCircle(player)
        end
    end
    if C.PlayerESP then
        for _, player in pairs(Services.Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            local char = player.Character
            if char then
                local billboard = char:FindFirstChild("ESP_Billboard")
                local text = billboard and billboard:FindFirstChild("ESP_Text")
                if text then
                    local dist = (char.HumanoidRootPart.Position - myRoot.Position).Magnitude
                    text.Text = string.format("%s\n[%d]", player.Name, dist)
                end
            end
        end
    end
end

function JJS_Core.Visuals:Init()
    Services.Players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function(char)
            task.wait(0.1)
            if JJS_Core.Config.PlayerESP then self:AddESP(char) end
            if JJS_Core.Config.RangeVisual then self:AddPlayerCircle(player) end
        end)
    end)
    Services.Players.PlayerRemoving:Connect(function(player)
        self:RemovePlayerCircle(player)
        if player.Character then self:ClearESP(player.Character) end
    end)
    self:RefreshESP()
    self:RefreshPlayerCircles()
end

-- ===================================================================
-- ===== 8. HOOKS MODULE (Player & VFX)
-- ===================================================================
JJS_Core.Hooks = {}

--- Hooks to the local player's character.
function JJS_Core.Hooks:InitPlayer()
    LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        JJS_Core.Cache.Humanoid = char:WaitForChild("Humanoid")
        JJS_Core.Cache.Animator = JJS_Core.Cache.Humanoid:WaitForChild("Animator")
        JJS_Core.Cache.RootPart = char:WaitForChild("HumanoidRootPart")
    end)
    if LocalPlayer.Character then
        local char = LocalPlayer.Character
        JJS_Core.Cache.Humanoid = char:FindFirstChildOfClass("Humanoid")
        JJS_Core.Cache.Animator = JJS_Core.Cache.Humanoid and JJS_Core.Cache.Humanoid:FindFirstChildOfClass("Animator")
        JJS_Core.Cache.RootPart = char:FindFirstChild("HumanoidRootPart")
    end
end

--- Monitors Workspace for new VFX parts.
function JJS_Core.Hooks:InitVFX()
    local Cache = JJS_Core.Cache
    local GD = JJS_Core.GameData
    
    local function remove(list, obj)
        for i = #list, 1, -1 do
            if list[i] == obj then
                table.remove(list, i)
                return
            end
        end
    end

    Services.Workspace.DescendantAdded:Connect(function(obj)
        if not obj:IsA("BasePart") then return end
        local name = obj.Name
        if GD.VFX_Triggers[name] then
            table.insert(Cache.Active_Triggers, obj)
        elseif GD.Dodge_Triggers[name] then
            table.insert(Cache.Active_Dangers, obj)
        end
    end)
    
    Services.Workspace.DescendantRemoving:Connect(function(obj)
        if not obj:IsA("BasePart") then return end
        local name = obj.Name
        if GD.VFX_Triggers[name] then
            remove(Cache.Active_Triggers, obj)
        elseif GD.Dodge_Triggers[name] then
            remove(Cache.Active_Dangers, obj)
        end
    end)
    
    -- Scan for any existing parts
    task.spawn(function()
        for _, obj in ipairs(Services.Workspace:GetDescendants()) do
            if obj:IsA("BasePart") then
                local name = obj.Name
                if GD.VFX_Triggers[name] then
                    table.insert(Cache.Active_Triggers, obj)
                elseif GD.Dodge_Triggers[name] then
                    table.insert(Cache.Active_Dangers, obj)
                end
            end
        end
        print("JJS Core: Initial VFX scan complete. Ready.")
    end)
end

-- ===================================================================
-- ===== 9. CORE FUNCTIONS (Combat, Utils)
-- ===================================================================

--- Fires the appropriate defensive action (Block or Counter).
function JJS_Core:FireDefensive()
    local Cache = JJS_Core.Cache
    local C = JJS_Core.Config
    local now = tick()
    if now - Cache.LastLocalBlockTime < C.LocalBlockCooldown then return end
    
    -- [STEALTH] Humanize the reaction
    self.Stealth:Humanize()
    
    -- Check for Auto Counter
    if C.AutoCounter and (now - Cache.LastAbilityTime > C.CounterAbilityCooldown) then
        if Cache.AbilityRemote then
            pcall(function()
                Cache.AbilityRemote:FireServer(C.CounterAbilitySlot) 
            end)
            Cache.LastAbilityTime = tick()
            Cache.LastLocalBlockTime = tick()
            return
        end
    end
    
    -- Default to Block
    if Cache.BlockRemote then
        pcall(function()
            Cache.BlockRemote:FireServer()
        end)
        Cache.LastLocalBlockTime = tick()
    end
end

--- Main Aimbot Logic.
function JJS_Core:UpdateAimbot()
    local C = JJS_Core.Config
    local Cache = JJS_Core.Cache
    if not C.Aimbot or not Cache.RootPart then return end

    local bestTarget, bestDist = nil, C.Aimbot_Range
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (Cache.RootPart.Position - hrp.Position).Magnitude
                if dist < bestDist then
                    bestTarget, bestDist = hrp, dist
                end
            end
        end
    end
    
    if bestTarget then
        Cache.RootPart.CFrame = CFrame.lookAt(Cache.RootPart.Position, Vector3.new(bestTarget.Position.X, Cache.RootPart.Position.Y, bestTarget.Position.Z))
    end
end

--- Main Auto-Dodge Logic.
function JJS_Core:UpdateAutoDodge()
    local C = JJS_Core.Config
    local Cache = JJS_Core.Cache
    if not C.AutoDodge or not Cache.RootPart then return end
    
    local now = tick()
    if now - Cache.LastDodgeTime < C.Dodge_Cooldown then return end
    
    for i = #Cache.Active_Dangers, 1, -1 do
        local part = Cache.Active_Dangers[i]
        if not (part and part.Parent) then
            table.remove(Cache.Active_Dangers, i)
            continue
        end
        
        local dist = (Cache.RootPart.Position - part.Position).Magnitude
        if dist <= C.Dodge_Range then
            Cache.LastDodgeTime = now
            
            -- Teleport logic from the script
            local dir = (Cache.RootPart.Position - part.Position).Unit
            local tgt = Cache.RootPart.Position + (dir * C.Dodge_Distance) -- Teleport away
            
            -- Raycast down to find the floor
            local rayO = tgt + Vector3.new(0, 50, 0)
            local rayD = Vector3.new(0, -150, 0)
            local rp = RaycastParams.new()
            rp.FilterDescendantsInstances = {LocalPlayer.Character}
            rp.FilterType = Enum.RaycastFilterType.Blacklist
            local res = Services.Workspace:Raycast(rayO, rayD, rp)
            
            if res then
                tgt = Vector3.new(tgt.X, res.Position.Y + 2, tgt.Z)
            else
                tgt = Vector3.new(tgt.X, Cache.RootPart.Position.Y, tgt.Z)
            end
            
            Cache.RootPart.CFrame = CFrame.new(tgt)
            break -- Only dodge one threat per frame
        end
    end
end

--- Main Auto-Block Logic (Hitbox-Based).
function JJS_Core:UpdateHitboxBlock()
    local C = JJS_Core.Config
    local Cache = JJS_Core.Cache
    if not C.AutoBlock or not Cache.RootPart then return end
    
    local now = tick()
    if now - Cache.LastLocalBlockTime < C.LocalBlockCooldown then return end

    for i = #Cache.Active_Triggers, 1, -1 do
        local part = Cache.Active_Triggers[i]
        if not (part and part.Parent) then
            table.remove(Cache.Active_Triggers, i)
            continue
        end
        
        local dist = (Cache.RootPart.Position - part.Position).Magnitude
        
        -- Special case from the script you found
        if part.Name == "CombatTrail" and dist <= 1 then
            -- This is a "too-close" check, we ignore it.
        elseif dist >= C.Block_MinRange and dist <= C.Block_MaxRange then
            -- This is a valid threat
            self:FireDefensive()
            break -- Only block one threat per frame
        end
    end
end

-- ===================================================================
-- ===== 10. RAYFIELD UI INITIALIZATION
-- ===================================================================
function JJS_Core:InitUI()
    local C = JJS_Core.Config
    
    local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
    
    local Window = Rayfield:CreateWindow({
        Name = self.Stealth:GetRandomName(),
        LoadingTitle = self.Stealth:GetRandomName(),
        LoadingSubtitle = "by " .. self.Stealth:GetRandomName(),
        ConfigurationSaving = {
            Enabled = true,
            FolderName = "JJS_HubConfig_v4",
            FileName = "Settings"
        },
        Discord = { Enabled = false },
        KeySystem = false
    })
    
    -- AutoBlockTab
    local AutoBlockTab = Window:CreateTab("Auto Block", 4483362458)
    AutoBlockTab:CreateParagraph({
        Title = "Hitbox-Based Auto Block",
        Content = "This script works by detecting the *Names* of attack VFX parts. Add/remove names in the script's `VFX_Triggers` list."
    })
    AutoBlockTab:CreateToggle({
        Name = "Auto Block (Hitbox)", CurrentValue = C.AutoBlock, Flag = "AutoBlockHitbox",
        Callback = function(Value) C.AutoBlock = Value end
    })
    AutoBlockTab:CreateSlider({
        Name = "Block Min Distance", Range = {0, 10}, Suffix = "s", CurrentValue = C.Block_MinRange, Flag = "BlockMinRange",
        Callback = function(val) C.Block_MinRange = val end
    })
    AutoBlockTab:CreateSlider({
        Name = "Block Max Distance", Range = {5, 30}, Suffix = "s", CurrentValue = C.Block_MaxRange, Flag = "BlockMaxRange",
        Callback = function(val) C.Block_MaxRange = val end
    })
    
    AutoBlockTab:CreateParagraph({ Title = "Auto Dodge" })
    AutoBlockTab:CreateToggle({
        Name = "Auto Dodge (Teleport)", CurrentValue = C.AutoDodge, Flag = "AutoDodgeToggle",
        Callback = function(Value) C.AutoDodge = Value end
    })
    AutoBlockTab:CreateSlider({
        Name = "Dodge Trigger Range", Range = {10, 100}, Suffix = "s", CurrentValue = C.Dodge_Range, Flag = "DodgeRange",
        Callback = function(val) C.Dodge_Range = val end
    })
    AutoBlockTab:CreateSlider({
        Name = "Dodge Teleport Distance", Range = {10, 100}, Suffix = "s", CurrentValue = C.Dodge_Distance, Flag = "DodgeDistance",
        Callback = function(val) C.Dodge_Distance = val end
    })
    AutoBlockTab:CreateSlider({
        Name = "Dodge Cooldown", Range = {0.5, 5}, Suffix = "s", CurrentValue = C.Dodge_Cooldown, Flag = "DodgeCooldown",
        Callback = function(val) C.Dodge_Cooldown = val end
    })
    
    AutoBlockTab:CreateParagraph({ Title = "Auto Counter" })
    AutoBlockTab:CreateToggle({
        Name = "Auto Ability Counter", CurrentValue = C.AutoCounter, Flag = "AutoCounterToggle",
        Callback = function(Value) C.AutoCounter = Value end
    })
    AutoBlockTab:CreateInput({
        Name = "Counter Ability Slot (1-5)", PlaceholderText = C.CounterAbilitySlot, Flag = "CounterAbilitySlot",
        Callback = function(Text) C.CounterAbilitySlot = tonumber(Text) or C.CounterAbilitySlot end
    })
    AutoBlockTab:CreateSlider({
        Name = "Auto Counter Cooldown", Range = {1, 30}, CurrentValue = C.CounterAbilityCooldown, Flag = "CounterAbilityCooldown",
        Callback = function(val) C.CounterAbilityCooldown = val end
    })
    
    AutoBlockTab:CreateParagraph({ Title = "[STEALTH] Settings" })
    AutoBlockTab:CreateSlider({
        Name = "Local Block Cooldown", Range = {0.1, 1.0}, Suffix = "s", CurrentValue = C.LocalBlockCooldown, Flag = "LocalCooldownSlider",
        Callback = function(val) C.LocalBlockCooldown = val end
    })
    AutoBlockTab:CreateSlider({
        Name = "Min Reaction Time", Range = {10, 250}, Suffix = "ms", CurrentValue = C.MinReactionMS, Flag = "MinReactionTime",
        Callback = function(val) C.MinReactionMS = val end
    })
    AutoBlockTab:CreateSlider({
        Name = "Max Reaction Time", Range = {10, 250}, Suffix = "ms", CurrentValue = C.MaxReactionMS, Flag = "MaxReactionTime",
        Callback = function(val) C.MaxReactionMS = val end
    })
    
    -- CombatTab
    local CombatTab = Window:CreateTab("Combat", 4483362458)
    CombatTab:CreateToggle({
        Name = "Aimbot", CurrentValue = C.Aimbot, Flag = "AimbotToggle",
        Callback = function(Value) C.Aimbot = Value end
    })
    AutoBlockTab:CreateSlider({
        Name = "Aimbot Range", Range = {10, 100}, Suffix = "s", CurrentValue = C.Aimbot_Range, Flag = "AimbotRange",
        Callback = function(val) C.Aimbot_Range = val end
    })
    
    -- VisualsTab
    local VisualsTab = Window:CreateTab("Visuals", 4483362458)
    VisualsTab:CreateToggle({
        Name = "Player ESP", CurrentValue = C.PlayerESP, Flag = "PlayerESPToggle",
        Callback = function(Value) C.PlayerESP = Value; self.Visuals:RefreshESP() end
    })
    VisualsTab:CreateToggle({
        Name = "Range Visual (Max Block)", CurrentValue = C.RangeVisual, Flag = "PlayerCircleToggle",
        Callback = function(state) C.RangeVisual = state; self.Visuals:RefreshPlayerCircles() end
    })
    
    -- MiscTab
    local MiscTab = Window:CreateTab("Misc", 4483362458)
    MiscTab:CreateButton({
        Name = "Run Infinite Yield",
        Callback = function() loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))() end
    })
    
    return Window
end

-- ===================================================================
-- ===== 11. MAIN INITIALIZATION
-- ===================================================================
function JJS_Core:Init()
    -- 1. Find Remote Events
    local GD = JJS_Core.GameData
    local Cache = JJS_Core.Cache
    pcall(function()
        Cache.BlockRemote = Services.ReplicatedStorage:FindFirstChild(GD.Remotes.Block, true)
        Cache.AbilityRemote = Services.ReplicatedStorage:FindFirstChild(GD.Remotes.Ability, true)
    end)
    if not Cache.BlockRemote then
        warn("JJS Core: FAILED to find Block/Parry remote. Check GameData config. Auto-Block WILL NOT work.")
    else
        print("JJS Core: Block/Parry remote found and linked.")
    end
    if not Cache.AbilityRemote then
        warn("JJS Core: FAILED to find Ability remote. Auto-Counter WILL NOT work.")
    else
        print("JJS Core: Ability remote found and linked.")
    end

    -- 2. Initialize Hooks
    self.Hooks:InitPlayer()
    self.Hooks:InitVFX()
    
    -- 3. Initialize Visuals
    self.Visuals:Init()

    -- 4. Initialize UI
    local Window = self:InitUI()
    
    -- 5. Load Configuration
    Window:LoadConfiguration()
    
    -- 6. Start Main Loops
    Services.RunService.Heartbeat:Connect(function()
        -- Refresh RootPart cache if needed (robustness)
        if not Cache.RootPart or not Cache.RootPart.Parent then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                Cache.RootPart = LocalPlayer.Character.HumanoidRootPart
            else
                return -- Can't run combat logic without a root part
            end
        end
        
        -- Run all logic. No throttles.
        self:UpdateAimbot()
        self:UpdateAutoDodge()
        self:UpdateHitboxBlock()
    end)
    
    Services.RunService.RenderStepped:Connect(function()
        -- Visuals run on RenderStepped for smoothness
        self.Visuals:Update()
    end)
    
    print("JJS Auto-Defense Core (v4.0 - Hitbox Detection) Initialized.")
end

-- ===================================================================
-- ===== 12. EXECUTE
-- ===================================================================
JJS_Core:Init()
